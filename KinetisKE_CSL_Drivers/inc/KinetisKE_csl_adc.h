/**
 * Title 	ADC module in CSL for KEAZxxx(Header File)
 * License	GPLv2.0
 * Author	Stark Zhang
 * Debug	None
**/

/** This Module will be started by Initialization, no extra operations */

#ifndef __KinetisKE_CSL_ADC_H
#define __KinetisKE_CSL_ADC_H

#ifdef __cplusplus
 extern "C" {
#endif /*__cplusplus*/

#include "KinetisKE_csl.h"

/**
 * ADC Convert Mode
**/
typedef enum
{
	Single		= 0x00u,
	Continuous	= 0x20u,
}ADC_ConvertTypeDef;

/**
 * ADC FIFO Structure
**/
typedef struct
{
	FunctionalState state;
	FunctionalState Scan;
	uint8_t Depth;
	uint8_t TrigMode;
	uint8_t FifoComp;
	uint8_t Channel[8];
}ADC_FIFOTypeDef;

/** 
 * ADC Compare Structure
**/
typedef struct
{
	FunctionalState state;
	uint8_t CompMode;
	uint16_t CompValue;
}ADC_CompTypeDef;

/**
 * ADC Hardware Trigger
**/
typedef struct
{
	uint8_t state;
	uint32_t HardTrigger;
}ADC_TrigTypeDef;

/**
 * ADC Initialize Structure(Basic)
**/
typedef struct
{
	ADC_ConvertTypeDef ConvMode;
	uint8_t Channel;
	uint8_t Reference;
	uint8_t Clock;
	uint8_t PreScaler;
	uint8_t Length;
}ADC_InitTypeDef;

/**
 * ADC States
**/
typedef enum
{
	CSL_ADC_STATE_RESET 	= 0x00u,			//ADC is Reset
	CSL_ADC_STATE_READY		= 0x01u,			//ADC is Ready
	CSL_ADC_STATE_CPLT		= 0x02u,			//ADC is Convertion Complete
	CSL_ADC_STATE_FULL		= 0x03u,			//ADC FIFO is FULL
}ADC_StateTypeDef;

/**
 * ADC Handle TypeDef
**/
typedef struct
{
	ADC_StateTypeDef 		gState;				//Global State of ADC
	ADC_InitTypeDef 		Init;				//Initialized Structure
	ADC_FIFOTypeDef 		FIFO;				//FIFO Configuration Structure
	ADC_CompTypeDef 		Compare;			//Compare Configuration Structure
	ADC_TrigTypeDef 		Trigger;			//Trigger Configuration Structure
}ADC_HandleTypeDef;

/**
 * ADC Channels
**/
#define ADC_Channel_0				0x00u
#define ADC_Channel_1				0x01u
#define ADC_Channel_2				0x02u
#define ADC_Channel_3				0x03u
#define ADC_Channel_4				0x04u
#define ADC_Channel_5				0x05u
#define ADC_Channel_6				0x06u
#define ADC_Channel_7				0x07u
#define ADC_Channel_8				0x08u
#define ADC_Channel_9				0x09u
#define ADC_Channel_10				0x0Au
#define ADC_Channel_11				0x0Bu
#define ADC_Channel_12				0x0Cu
#define ADC_Channel_13				0x0Du
#define ADC_Channel_14				0x0Eu
#define ADC_Channel_15				0x0Fu
#define ADC_Channel_Vss				0x10u				//Digital Ground
#define ADC_Channel_T				0x16u				//Temperature Sensor
#define ADC_Channel_BG				0x17u				//Bandgap Reference
#define ADC_Channel_RH				0x1Du				//Reference Low-Level
#define ADC_Channel_RL				0x1Eu				//Reference High-Level
#define ADC_Channel_None			0x1Fu				//Disable ADC & Reset ADC FIFO

/**
 * ADC Voltage Reference
**/
#define ADC_REF_ExtREF				0x00u				//External Reference Pins
#define ADC_REF_VDDA				0x01u				//VDDA & VSSA pins
#define ADC_REF_Default				0x03u				//Default to select VREF(VREF pins)

/**
 * ADC Clock Source
**/
#define ADC_CLK_BusClock			0x00u				//Bus Clock
#define ADC_CLK_BusClock_DIV2		0x01u				//Bus Clock with Divider 2
#define ADC_CLK_ALTCLK				0x02u				//Alternative Clock
#define ADC_CLK_ADACK				0x03u				//Clock Generated by ADC

/**
 * ADC Clock Divider
**/
#define ADC_CLK_DIV1				0x00u				//Divider 1
#define ADC_CLK_DIV2				0x20u				//Divider 2
#define ADC_CLK_DIV4				0x40u				//Divider 4
#define ADC_CLK_DIV8				ADC_SC3_ADIV_MASK	//Divider 8

/**
 * ADC Data Length
**/
#define ADC_DATA_LEN8				0x00u				//Length is 8 bits
#define ADC_DATA_LEN10				0x04u				//Length is 10 bits
#define ADC_DATA_LEN12				0x08u				//Length is 12 bits

/**
 * ADC Trigger Source
**/
#define ADC_TRIG_SOFTWARE			0x00u				//Software Trigger
#define ADC_TRIG_HARDWARE			0x40u				//Hardware Trigger

/**
 * ADC Hardware Trigger
**/
#define ADC_HTRIG_RTCOR				0x00000000u			//RTC Overrun
#define ADC_HTRIG_FTM0				0x00100000u			//FTM0
#define ADC_HTRIG_FTM2INIT			0x00200000u			//FTM2 Init Trigger with 8-bit Counter Delay
#define ADC_HTRIG_FTM2MATCH			0x00300000u			//FTM2 Match Trigger with 8-bit Counter Delay
#define ADC_HTRIG_PITCH0			0x00400000u			//PIT Channel0 Overrun
#define ADC_HTRIG_PITCH1			0x00500000u			//PIT Channel1 Overrun
#define ADC_HTRIG_ACMP0				0x00600000u			//ACMP0 Output
#define ADC_HTRIG_ACMP1				0x007000000u		//ACMP1 Output

/**
 * ADC Compare Mode
**/
#define ADC_COMPARE_LOW				0x00u				//Result < CompValue, Convert is over
#define ADC_COMPARE_HIGH			0x01u				//Result > CompValue, Convert is over

/**
 * ADC FIFO Depth(Depth 1 is FIFO Scan Mode)
**/
#define ADC_FIFO_D0					0x00u				//Disable FIFO
#define ADC_FIFO_D2					0x01u				//Depth 2
#define ADC_FIFO_D3					0x02u				//Depth 3
#define ADC_FIFO_D4					0x03u				//Depth 4
#define ADC_FIFO_D5					0x04u				//Depth 5
#define ADC_FIFO_D6					0x05u				//Depth 6 
#define ADC_FIFO_D7					0x06u				//Depth 7
#define ADC_FIFO_D8					0x07u				//Depth 8

/**
 * ADC FIFO Trigger Mode
**/
#define ADC_FTRIG_ONCE				0x00u				//once conversion by a Hardware Trigger
#define ADC_FTRIG_CONTINUOUS		0x01u				//continuous conversion by a Hardware Trigger

/**
 * ADC FIFO Compare Mode
**/
#define ADC_FIFO_COMP_OR			0x00u				//FIFO Compare is OR, a valid value can SET COCO
#define ADC_FIFO_COMP_AND			0x01u				//FIFO Compare is AND, all values are valid, COCO SET

/* Macros Functions */
/**
 * @brief 	Get an ADC Value after conversions
**/
#define __CSL_ADC_GET_VALUE()			(READ_REG(ADC->R))

/**
 * @brief 	Get ADC Status from Status & Control Registers
 * @param	REG
				Registers
 * @param	BIT
				Bits in Registers
**/
#define __CSL_ADC_GET_STATE(REG, BIT)		((REG & BIT) ? SET : RESET)

/**
 * @brief 	Enable/Disable ADC Interrupt
**/
#define __CSL_ADC_IT_ENABLE()				(ADC->SC1 |= ADC_SC1_AIEN_MASK)
#define __CSL_ADC_IT_DISABLE()				(ADC->SC1 &= ~ADC_SC1_AIEN_MASK)

/* Public Functions of ADC */
CSL_StatusTypeDef CSL_ADC_Init(ADC_HandleTypeDef* cadc);
CSL_StatusTypeDef CSL_ADC_DeInit(ADC_HandleTypeDef* cadc);
void CSL_ADC_MspInit(ADC_HandleTypeDef* cadc);
void CSL_ADC_MspDeInit(ADC_HandleTypeDef* cadc);

uint16_t CSL_ADC_GetSingleValue(ADC_HandleTypeDef* cadc);
CSL_StatusTypeDef CSL_ADC_GetFIFOValues(ADC_HandleTypeDef* cadc, uint16_t* pBuffer, uint8_t Size);

//ADC Interrupt
void CSL_ADC_IRQHandler(ADC_HandleTypeDef* cadc);
void CSL_ADC_ConvCpltCallback(ADC_HandleTypeDef* cadc);

/* Defgroup for ADC Module Parameters Check */
#define IS_ADC_Channel(ch)				((ch == ADC_Channel_0) || \
										 (ch == ADC_Channel_1) || \
										 (ch == ADC_Channel_2) || \
										 (ch == ADC_Channel_3) || \
										 (ch == ADC_Channel_4) || \
										 (ch == ADC_Channel_5) || \
										 (ch == ADC_Channel_6) || \
										 (ch == ADC_Channel_7) || \
										 (ch == ADC_Channel_8) || \
										 (ch == ADC_Channel_9) || \
										 (ch == ADC_Channel_10) || \
										 (ch == ADC_Channel_11) || \
										 (ch == ADC_Channel_12) || \
										 (ch == ADC_Channel_13) || \
										 (ch == ADC_Channel_14) || \
										 (ch == ADC_Channel_15) || \
										 (ch == ADC_Channel_Vss) || \
										 (ch == ADC_Channel_T) || \
										 (ch == ADC_Channel_BG) || \
										 (ch == ADC_Channel_RH) || \
										 (ch == ADC_Channel_RL) || \
										 (ch == ADC_Channel_None))
#define IS_ADC_REF(ref)					((ref == 0x00u) || (ref == 0x01u) || (ref == 0x03u))
#define IS_ADC_CLKSource(clk)			((clk == 0x00u) || (clk == 0x01u) || (clk == 0x02u) || (clk == 0x03u))
#define IS_ADC_CLKPSC(div)				((div == 0x00u) || (div == 0x01u) || (div == 0x02u) || (div == 0x03u))

#ifdef __cplusplus
 }
#endif /*__cplusplus*/

#endif /*__KinetisKE_CSL_ADC_H*/

//EOF
